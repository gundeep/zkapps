var rt=Object.create;var le=Object.defineProperty;var st=Object.getOwnPropertyDescriptor;var ot=Object.getOwnPropertyNames;var it=Object.getPrototypeOf,at=Object.prototype.hasOwnProperty;var ze=r=>le(r,"__esModule",{value:!0});var lt=(r,e)=>()=>(r&&(e=r(r=0)),e);var ut=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),ue=(r,e)=>{ze(r);for(var t in e)le(r,t,{get:e[t],enumerable:!0})},ct=(r,e,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of ot(e))!at.call(r,s)&&s!=="default"&&le(r,s,{get:()=>e[s],enumerable:!(t=st(e,s))||t.enumerable});return r},ce=r=>ct(ze(le(r!=null?rt(it(r)):{},"default",r&&r.__esModule&&"default"in r?{get:()=>r.default,enumerable:!0}:{value:r,enumerable:!0})),r);var Ve={};ue(Ve,{proxyClasses:()=>ht});function ht(r,e,t){let s={};for(let n of e){let o=n.name,i=function(...a){if(!t())throw Error(pt(o));let c=r();return new c[o](...a)};for(let a of n.props){let c=a.name;a.type==="function"?i[c]=function(...h){if(!t())throw Error(dt(o,c));return r()[o][c].apply(this,h)}:Object.defineProperty(i,c,{get:function(){return r()[o][c]}})}s[o]=i}return s}var pt,dt,Oe=lt(()=>{pt=r=>`Cannot call class constructor because snarkyjs has not finished loading.
Try calling \`await isReady\` before \`new ${r}()\``,dt=(r,e)=>`Cannot call static method because snarkyjs has not finished loading.
Try calling \`await isReady\` before \`${r}.${e}()\``});var He=ut((Gt,ft)=>{ft.exports=[{name:"Field",props:[{name:"one",type:"object"},{name:"zero",type:"object"},{name:"random",type:"function"},{name:"add",type:"function"},{name:"sub",type:"function"},{name:"mul",type:"function"},{name:"div",type:"function"},{name:"neg",type:"function"},{name:"inv",type:"function"},{name:"square",type:"function"},{name:"sqrt",type:"function"},{name:"toString",type:"function"},{name:"sizeInFields",type:"function"},{name:"toFields",type:"function"},{name:"ofFields",type:"function"},{name:"assertEqual",type:"function"},{name:"assertBoolean",type:"function"},{name:"isZero",type:"function"},{name:"ofBits",type:"function"},{name:"toBits",type:"function"},{name:"equal",type:"function"},{name:"toConstant",type:"function"},{name:"toJSON",type:"function"},{name:"fromJSON",type:"function"}]},{name:"Bool",props:[{name:"toField",type:"function"},{name:"Unsafe",type:"object"},{name:"not",type:"function"},{name:"and",type:"function"},{name:"or",type:"function"},{name:"assertEqual",type:"function"},{name:"equal",type:"function"},{name:"isTrue",type:"function"},{name:"isFalse",type:"function"},{name:"count",type:"function"},{name:"sizeInFields",type:"function"},{name:"toFields",type:"function"},{name:"ofFields",type:"function"},{name:"check",type:"function"},{name:"toJSON",type:"function"},{name:"fromJSON",type:"function"}]},{name:"Circuit",props:[{name:"asProver",type:"function"},{name:"inProver",type:"function"},{name:"inCheckedComputation",type:"function"},{name:"runAndCheck",type:"function"},{name:"witness",type:"function"},{name:"array",type:"function"},{name:"generateKeypair",type:"function"},{name:"prove",type:"function"},{name:"verify",type:"function"},{name:"assertEqual",type:"function"},{name:"equal",type:"function"},{name:"toFields",type:"function"},{name:"if",type:"function"}]},{name:"Poseidon",props:[{name:"hash",type:"function"}]},{name:"Group",props:[{name:"generator",type:"object"},{name:"add",type:"function"},{name:"sub",type:"function"},{name:"neg",type:"function"},{name:"scale",type:"function"},{name:"assertEqual",type:"function"},{name:"equal",type:"function"},{name:"toFields",type:"function"},{name:"ofFields",type:"function"},{name:"sizeInFields",type:"function"},{name:"check",type:"function"},{name:"toJSON",type:"function"},{name:"fromJSON",type:"function"}]},{name:"Scalar",props:[{name:"toFields",type:"function"},{name:"sizeInFields",type:"function"},{name:"ofFields",type:"function"},{name:"random",type:"function"},{name:"ofBits",type:"function"},{name:"toJSON",type:"function"},{name:"fromJSON",type:"function"}]},{name:"Ledger",props:[{name:"create",type:"function"}]}]});ue(exports,{AccountPredicate:()=>U,AccumulatorMembershipProof:()=>Z,Amount:()=>It,Balance:()=>Pt,Body:()=>V,Bool:()=>p,Circuit:()=>d,CircuitValue:()=>C,ClosedInterval:()=>we,Collection:()=>Xe,DataStore:()=>Ae,EpochDataPredicate:()=>Te,EpochLedgerPredicate:()=>_e,Events:()=>Me,Fee:()=>_t,Field:()=>u,GlobalSlot:()=>Tt,Group:()=>A,Index:()=>R,IndexBase:()=>ke,IndexFactory:()=>Re,IndexedAccumulator:()=>xe,Int64:()=>M,KeyedAccumulatorFactory:()=>Ct,Ledger:()=>ve,MerkleAccumulatorFactory:()=>Et,MerkleList:()=>Ie,MerkleProof:()=>be,MerkleProofFactory:()=>Q,MerkleStack:()=>ye,Mina:()=>qe,Optional:()=>he,OrIgnore:()=>Pe,Party:()=>J,PartyBalance:()=>Be,Perm:()=>E,Permissions:()=>se,Poseidon:()=>w,PrivateKey:()=>L,ProofWithInput:()=>tt,ProtocolStatePredicate:()=>G,PublicKey:()=>H,Scalar:()=>O,SetOrKeep:()=>Ee,Signature:()=>j,SignedAmount:()=>Bt,SmartContract:()=>Ne,State:()=>D,String_:()=>Ye,Timing:()=>We,TokenSymbol:()=>Ze,Tree:()=>te,UInt32:()=>f,UInt64:()=>g,Update:()=>Ce,arrayProp:()=>xt,asFieldElementsToConstant:()=>vt,branch:()=>jt,circuitMain:()=>St,getDefaultTokenId:()=>Qe,init:()=>Jt,isReady:()=>yt,matrixProp:()=>kt,method:()=>Dt,proofSystem:()=>$t,prop:()=>_,public_:()=>bt,shutdown:()=>wt,state:()=>Kt});var{proxyClasses:mt}=(Oe(),Ve),Le=require("./node_bindings/snarky_js_node.bc.js"),gt=He(),{Field:u,Bool:p,Circuit:d,Poseidon:w,Group:A,Scalar:O,Ledger:ve}=mt(()=>Le,gt,()=>Ke),Ke=!1,yt=Le.snarky_ready.then(()=>{Ke=!0}),De=!1;function wt(){if(global.wasm_rayon_poolbuilder&&!De)return De=!0,global.wasm_rayon_poolbuilder.free(),Promise.all(global.wasm_workers.map(async r=>{await r.terminate()}))}var N=ce(require("tslib"));var Ut=ce(require("reflect-metadata"));function vt(r,e){let t=r.toFields(e);return r.ofFields(t)}var C=class{static sizeInFields(){return this.prototype._fields.reduce((t,[s,n])=>t+n.sizeInFields(),0)}static toFields(e){let t=[],s=this.prototype._fields;if(s==null)return t;for(let n=0,o=s.length;n<o;++n){let[i,a]=s[n];a.toFields(e[i]).forEach(h=>t.push(h))}return t}toFields(){return this.constructor.toFields(this)}toJSON(){return this.constructor.toJSON(this)}equals(e){return d.equal(this,e)}assertEquals(e){d.assertEqual(this,e)}static ofFields(e){let t=this.prototype._fields,s=0,n=[];for(let o=0;o<t.length;++o){let i=t[o][1],a=i.sizeInFields(),c=i.ofFields(e.slice(s,s+a));n.push(c),s+=a}return new this(...n)}static toConstant(e){let t=this.toFields(e);return this.ofFields(t.map(s=>s.toConstant()))}static toJSON(e){let t={};return this.prototype._fields!==void 0&&this.prototype._fields.forEach(([n,o])=>{t[n]=o.toJSON(e[n])}),t}static fromJSON(e){let t=[],s=this.prototype._fields;switch(typeof e){case"object":if(e===null||Array.isArray(e))return null;break;default:return null}if(s!==void 0)for(let n=0;n<s.length;++n){let[o,i]=s[n];if(e[o]===void 0)return null;t.push(i.fromJSON(e[o]))}return new this(...t)}};C.check=function(r){let e=this.prototype._fields;if(e!=null)for(let t=0;t<e.length;++t){let[s,n]=e[t],o=r[s];n.check!=null&&n.check(o)}};function _(r,e){let t=Reflect.getMetadata("design:type",r,e);(r._fields===void 0||r._fields===null)&&(r._fields=[]),t===void 0||(t.toFields&&t.ofFields?r._fields.push([e,t]):console.log(`warning: property ${e} missing field element conversion methods`))}function xt(r,e){return function(t,s){(t._fields===void 0||t._fields===null)&&(t._fields=[]),t._fields.push([s,d.array(r,e)])}}function kt(r,e,t){return function(s,n){s._fields??(s._fields=[]),s._fields.push([n,d.array(d.array(r,t),e)])}}function bt(r,e,t){r._public===void 0&&(r._public=[]),r._public.push(t)}function Je(r){return{sizeInFields:()=>r.reduce((e,t)=>e+t.sizeInFields(),0),toFields:e=>{if(e.length!==r.length)throw new Error(`typOfArray: Expected ${r.length}, got ${e.length}`);let t=[];for(let s=0;s<e.length;++s)t.push(...r[s].toFields(e[s]));return t},ofFields:e=>{let t=0,s=[];return r.forEach(n=>{let o=n.sizeInFields();s.push(n.ofFields(e.slice(t,t+o))),t+=o}),s}}}function St(r,e,t){let s=Reflect.getMetadata("design:paramtypes",r,e),n=s.length,o=new Set(r._public),i=new Set;for(let a=0;a<n;++a)o.has(a)||i.add(a);r.snarkyMain=(a,c)=>{let h=[];for(let l=0;l<n;++l)h.push((o.has(l)?c:a).shift());return r[e].apply(r,h)},r.snarkyWitnessTyp=Je(Array.from(i).map(a=>s[a])),r.snarkyPublicTyp=Je(Array.from(o).map(a=>s[a]))}var L=class extends C{constructor(e){super();this.s=e}static random(){return new L(O.random())}static ofBits(e){return new L(O.ofBits(e))}toPublicKey(){return new H(A.generator.scale(this.s))}};(0,N.__decorate)([_,(0,N.__metadata)("design:type",O)],L.prototype,"s",void 0);var H=class extends C{constructor(e){super();this.g=e}static fromPrivateKey(e){return e.toPublicKey()}};(0,N.__decorate)([_,(0,N.__metadata)("design:type",A)],H.prototype,"g",void 0);var j=class extends C{constructor(e,t){super();this.r=e,this.s=t}static create(e,t){let{g:s}=H.fromPrivateKey(e),n=e.s,o=O.random(),{x:i,y:a}=A.generator.scale(o),c=a.toBits()[0].toBoolean()?o.neg():o,l=O.ofBits(w.hash(t.concat([s.x,s.y,i])).toBits()).mul(n).add(c);return new j(i,l)}verify(e,t){let s=e.g,n=O.ofBits(w.hash(t.concat([s.x,s.y,this.r])).toBits()),o=s.scale(n).neg().add(A.generator.scale(this.s));return p.and(o.x.equals(this.r),o.y.toBits()[0].equals(!1))}};(0,N.__decorate)([_,(0,N.__metadata)("design:type",u)],j.prototype,"r",void 0);(0,N.__decorate)([_,(0,N.__metadata)("design:type",O)],j.prototype,"s",void 0);var pe=ce(require("tslib"));var he=class{constructor(e,t){this.isSome=e,this.value=t}};var Ft=0,Z=class{constructor(e,t){this.merkleProof=e,this.index=t}verify(e,t){let s=w.hash(t.toFields());return this.merkleProof.verify(e,this.index,s)}};function Et(r){let e=R[r],t=be[r];return class de{constructor(n){this.root=n,this._store=null}static fromStore(n){let o=new de(n.commitment());return o.store=n,o}static sizeInFields(){return 1}static toFields(n){return[n.root]}static ofFields(n){return new de(n[0])}toFields(){return de.toFields(this)}get store(){if(this._store===null)throw new Error("MerkleAccumulator.store not set");return this._store}set store(n){if(n.depth!==r)throw new Error(`Store had depth ${n.depth} but contract expects ${r}`);this._store=n}commitment(){return this.root}check(n,o){return o.verify(this.commitment(),n)}getMembershipProof(n){let o=this.store.getIndex(n);return o===null?null:new Z(this.store.getProof(o),o)}add(n){let o=d.witness(e,()=>this.store.nextIndex()),i=d.witness(t,()=>this.store.getProof(o));ee(o.value,i.path,Se(0)).assertEquals(this.root);let a=w.hash(n.toFields());return this.root=ee(o.value,i.path,a),d.inProver()?d.asProver(()=>{this.store.set(o,n)}):this.store.set(o,n),new Z(i,o)}}}var xe=class extends C{constructor(e){super();this.commitment=e}};(0,pe.__decorate)([_,(0,pe.__metadata)("design:type",u)],xe.prototype,"commitment",void 0);function Ct(r){let e=R[r],t=be[r];return class fe{constructor(n){this.root=n,this._store=null,this.cachedPaths=new Map,this.cachedValues=new Map,this.key=o=>{throw new Error("uninitialized")}}static create(n,o){let i=new fe(o.commitment());return i._store=o,i}static sizeInFields(){return 1}static toFields(n){return[n.root]}static ofFields(n){return new fe(n[0])}toFields(){return fe.toFields(this)}get store(){if(this._store===null)throw new Error("MerkleAccumulator.store not set");return this._store}set store(n){if(n.depth!==r)throw new Error(`Store had depth ${n.depth} but contract expects ${r}`);this._store=n}commitment(){return this.root}set(n,o){this.store.setValue(this.key(o),o)}get(n){let o=this.store.getIndex(n),i=new p(o!==null),a=o===null?this.store.nextIndex():o,{value:c,empty:h}=this.store.getValue(n),l=new he(i,c),y=this.store.getProof(a);return[l,new Z(y,a)]}}}var ke=class{constructor(e){this.value=e,this.id=Ft++}},$e=class{constructor(e){this.path=e}verify(e,t,s){return e.equals(ee(t.value,this.path,s))}assertVerifies(e,t,s){Fe(e,t.value,this.path,s)}};function Q(r){return class je extends $e{constructor(t){super(t)}static sizeInFields(){return r}static toFields(t){return t.path}static ofFields(t){if(t.length!==r)throw new Error(`MerkleTree: ofFields expected array of length ${r}, got ${t.length}`);return new je(t)}}}function Re(r){return class me extends ke{constructor(t){super(t)}static sizeInFields(){return r}static fromInt(t){if(t>=1<<r)throw new Error("Index is too large");let s=[];for(let n=0;n<r;++n)s.push(new p((t>>n&1)==1));return new me(s)}static ofFields(t){return new me(t.map(s=>p.Unsafe.ofField(s)))}toFields(){return me.toFields(this)}static toFields(t){return t.value.map(s=>s.toField())}static check(t){t.value.forEach(s=>s.toField().assertBoolean())}}}function Ge(r){let e=[];for(let t=0;t<r;++t)e.push(t);return e}var be=Ge(128).map(Q),R=Ge(128).map(Re),K=[];function Se(r){if(K.length===0&&K.push(new u(1234561789)),r>=K.length)for(let e=K.length;e<r+1;++e){let t=K[e-1];K.push(w.hash([t,t]))}return K[r]}function Mt(r,e,t){if(t.length===0)return ge(r);if(t.length>1<<r)throw new Error(`Length of elements (${t.length}) is greater than 2^depth = ${1<<r}`);let s=t.map(n=>({kind:"leaf",hash:e(n),value:n}));for(let n=0;n<r;++n){let o=[];for(let i=0;i<s.length>>1;++i){let a=s[2*i],c=s[2*i+1]||ge(n);o.push({kind:"node",hash:w.hash([a.hash,c.hash]),left:a,right:c})}s=o}return console.assert(s.length===1),s[0]}function ee(r,e,t){let s=t;for(let n=0;n<r.length;++n){let[o,i]=d.if(r[n],[e[n],s],[s,e[n]]);s=w.hash([o,i])}return s}function Fe(r,e,t,s){r.assertEquals(ee(e,t,s))}function ge(r){return{kind:"empty",depth:r,hash:Se(r)}}var te=class{constructor(e,t,s){this.value=Mt(e,t,s)}root(){return this.value.hash}setValue(e,t,s){let n=[],o=this.value;for(let i=e.length-1;i>=0;--i)switch(n.push(o),o.kind){case"leaf":throw new Error("Tree/index depth mismatch");case"empty":o.kind="node",o.left=ge(o.depth-1),o.right=ge(o.depth-1),delete o.depth,o=e[i]?o.right:o.left;break;case"node":o=e[i]?o.right:o.left;break;default:throw"unreachable"}switch(o.kind){case"empty":o.kind="leaf",o.value=t,delete o.depth,o.hash=s;break;case"leaf":o.hash=s,o.value=t;break;default:break}for(let i=n.length-1;i>=0;--i){if(o=n[i],o.kind!=="node")throw"unreachable";o.hash=w.hash([o.left.hash,o.right.hash])}}get(e){let t=this.value,s=e.length-1;for(let n=e.length-1;n>=0;--n)switch(t.kind){case"empty":return{value:null,hash:t.hash};case"leaf":return t;case"node":t=e[n]?t.right:t.left;break;default:break}throw new Error("Malformed merkle tree")}getValue(e){return this.get(e).value}getElementHash(e){return this.get(e).hash}getMerklePath(e){let t=[],s=this.value,n=!0,o=e.length-1;for(let i=e.length-1;i>=0;--i)switch(s.kind){case"empty":t.push(Se(i));break;case"node":t.push(e[i]?s.left.hash:s.right.hash),s=e[i]?s.right:s.left;break;case"leaf":throw new Error("Index/tree length mismatch.");default:throw"unreachable"}return t.reverse(),t}};function ne(r){return console.log("constantindex"),r.map(e=>e.toBoolean())}var Xe=class{constructor(e,t,s){this.eltTyp=e,this.cachedPaths=new Map,this.cachedValues=new Map,this.values={computed:!1,f:t},this.root=null}getRoot(){return this.root===null&&(this.root=this.getValues().root()),this.root}getValues(){if(this.values.computed)return this.values.value;{let e=this.values.f();return this.values={computed:!0,value:e},e}}set(e,t){let s=this.cachedPaths.get(e.id),n;if(s!==void 0)n=s;else{let a=e.value.length,c=d.array(u,a),h=d.witness(u,()=>this.getValues().getElementHash(ne(e.value)));n=d.witness(c,()=>this.getValues().getMerklePath(ne(e.value))),Fe(this.getRoot(),e.value,n,h)}let o=w.hash(this.eltTyp.toFields(t));this.cachedPaths.clear(),this.cachedValues.clear(),this.cachedPaths.set(e.id,n),this.cachedValues.set(e.id,{value:t,hash:o});let i=ee(e.value,n,o);d.asProver(()=>{this.getValues().setValue(ne(e.value),t,o.toConstant())}),this.root=i}get(e){let t=this.cachedValues.get(e.id);if(t!==void 0)return t.value;let s=e.value.length,n=d.array(u,s),o=d.witness(n,()=>this.getValues().getMerklePath(ne(e.value))),i=d.witness(this.eltTyp,()=>{let c=this.getValues().getValue(ne(e.value));if(c===null)throw new Error("Index not present in collection");return c}),a=w.hash(this.eltTyp.toFields(i));return this.cachedValues.set(e.id,{value:i,hash:a}),this.cachedPaths.set(e.id,o),Fe(this.getRoot(),e.value,o,a),i}};var ye=class{constructor(e,t){this.values={computed:!1,f:t},this.eltTyp=e,this.commitment=u.zero}static pushCommitment(e,t){return w.hash([t].concat(e.toFields()))}getValues(){if(this.values.computed===!0)return this.values.value;{let e=this.values.f();return this.values={computed:!0,value:e},e}}pop(){this.commitment.isZero().assertEquals(!1);let e=d.witness(u,()=>{let s=this.getValues(),[n,o]=s[s.length-1];return o}),t=d.witness(this.eltTyp,()=>{let n=this.getValues().pop();if(n===void 0)throw new Error("pop from empty list");return n[0]});return this.commitment.assertEquals(ye.pushCommitment(t,e)),this.commitment=e,t}};var z=ce(require("tslib"));function I(r,e){if(typeof e=="number"){if(!Number.isInteger(e))throw new Error(`${r} expected integer argument. Got ${e}`);return new u(e)}else return e.value}var g=class extends C{constructor(e){super();this.value=e}static get zero(){return new g(u.zero)}toString(){return this.value.toString()}static check(e){e.value.rangeCheckHelper(64).assertEquals(e.value)}static MAXINT(){return new g(u.fromJSON(((1n<<64n)-1n).toString()))}static fromNumber(e){return new g(I("UInt64.fromNumber",e))}divMod(e){let t=this.value,s=I("UInt64.div",e);if(this.value.isConstant()&&s.isConstant()){let c=BigInt(t.toString()),h=BigInt(s.toString()),l=c/h,y=c-l*h;return[new g(new u(l.toString())),new g(new u(y.toString()))]}s=s.seal();let n=d.witness(u,()=>new u((BigInt(t.toString())/BigInt(s.toString())).toString()));n.rangeCheckHelper(g.NUM_BITS).assertEquals(n);let o=t.sub(n.mul(s)).seal();o.rangeCheckHelper(g.NUM_BITS).assertEquals(o);let i=new g(o),a=new g(n);return i.assertLt(new g(s)),[a,i]}div(e){return this.divMod(e)[0]}mod(e){return this.divMod(e)[1]}mul(e){let t=this.value.mul(I("UInt64.mul",e));return t.rangeCheckHelper(g.NUM_BITS).assertEquals(t),new g(t)}add(e){let t=this.value.add(I("UInt64.add",e));return t.rangeCheckHelper(g.NUM_BITS).assertEquals(t),new g(t)}sub(e){let t=this.value.sub(I("UInt64.sub",e));return t.rangeCheckHelper(g.NUM_BITS).assertEquals(t),new g(t)}lte(e){let t=this.value.sub(I("UInt64.lte",e)).seal(),s=t.rangeCheckHelper(g.NUM_BITS).equals(t),n=t.rangeCheckHelper(g.NUM_BITS).equals(t.neg());return s.or(n).assertEquals(!0),n}assertLte(e){let t=I("UInt64.lt",e).sub(this.value).seal();t.rangeCheckHelper(g.NUM_BITS).assertEquals(t)}lt(e){return this.lte(e).and(this.value.equals(e.value).not())}assertLt(e){this.lt(e).assertEquals(!0)}gt(e){return e.lt(this)}assertGt(e){e.assertLt(this)}};g.NUM_BITS=64;(0,z.__decorate)([_,(0,z.__metadata)("design:type",u)],g.prototype,"value",void 0);var f=class extends C{constructor(e){super();this.value=e}static get zero(){return new f(u.zero)}toString(){return this.value.toString()}static check(e){e.value.rangeCheckHelper(32).assertEquals(e.value)}static fromNumber(e){return new f(I("UInt32.fromNumber",e))}static MAXINT(){return new f(u.fromJSON(((1n<<32n)-1n).toString()))}divMod(e){let t=this.value,s=I("UInt32.div",e);if(this.value.isConstant()&&s.isConstant()){let c=BigInt(t.toString()),h=BigInt(s.toString()),l=c/h,y=c-l*h;return[new f(new u(l.toString())),new f(new u(y.toString()))]}s=s.seal();let n=d.witness(u,()=>new u((BigInt(t.toString())/BigInt(s.toString())).toString()));n.rangeCheckHelper(f.NUM_BITS).assertEquals(n);let o=t.sub(n.mul(s)).seal();o.rangeCheckHelper(f.NUM_BITS).assertEquals(o);let i=new f(o),a=new f(n);return i.assertLt(new f(s)),[a,i]}div(e){return this.divMod(e)[0]}mod(e){return this.divMod(e)[1]}mul(e){let t=this.value.mul(I("UInt32.mul",e));return t.rangeCheckHelper(f.NUM_BITS).assertEquals(t),new f(t)}add(e){let t=this.value.add(I("UInt32.add",e));return t.rangeCheckHelper(f.NUM_BITS).assertEquals(t),new f(t)}sub(e){let t=this.value.sub(I("UInt32.sub",e));return t.rangeCheckHelper(f.NUM_BITS).assertEquals(t),new f(t)}lte(e){let t=this.value.sub(I("UInt32.lte",e)).seal(),s=t.rangeCheckHelper(f.NUM_BITS).equals(t),n=t.rangeCheckHelper(f.NUM_BITS).equals(t.neg());return s.or(n).assertEquals(!0),n}assertLte(e){let t=I("UInt32.lt",e).sub(this.value).seal();t.rangeCheckHelper(f.NUM_BITS).assertEquals(t)}lt(e){return this.lte(e).and(this.value.equals(e.value).not())}assertLt(e){this.lt(e).assertEquals(!0)}gt(e){return e.lt(this)}assertGt(e){e.assertLt(this)}};f.NUM_BITS=32;(0,z.__decorate)([_,(0,z.__metadata)("design:type",u)],f.prototype,"value",void 0);var re=class extends C{constructor(e){super();this.value=e}static check(e){let t=e.value.seal();t.mul(t).assertEquals(u.one)}static get Pos(){return new re(u.one)}static get Neg(){return new re(u.one.neg())}};(0,z.__decorate)([_,(0,z.__metadata)("design:type",u)],re.prototype,"value",void 0);var M=class{constructor(e){this.value=e}static check(){throw"todo: int64 check"}toString(){let e=this.value.toString();return BigInt(e)<1n<<64n?e:"-"+this.value.neg().toString()}static get zero(){return new M(u.zero)}static fromUnsigned(e){return new M(e.value)}static shift(){return u.fromJSON((1n<<64n).toString())}uint64Value(){return BigInt(this.value.toString())<1n<<64n?this.value:this.value.add(M.shift())}static sizeInFields(){return 1}neg(){return new M(this.value.neg())}add(e){return new M(this.value.add(e.value))}sub(e){return new M(this.value.sub(e.value))}repr(){throw"repr"}static toFields(e){return[e.value]}static ofFields(e){return new M(e[0])}toFields(){return M.toFields(this)}sizeInFields(){return M.sizeInFields()}};(0,z.__decorate)([_,(0,z.__metadata)("design:type",u)],M.prototype,"value",void 0);var qe={};ue(qe,{LocalBlockchain:()=>qt,currentSlot:()=>zt,currentTransaction:()=>b,getAccount:()=>W,getBalance:()=>Vt,nextTransactionId:()=>ie,setActiveInstance:()=>At,transaction:()=>Nt});var It=g,Pt=g,_t=g,Tt=f,Bt=M,Ue=8,We=class{constructor(e,t,s,n,o){this.initialMinimumBalance=e,this.cliffTime=t,this.cliffAmount=s,this.vestingPeriod=n,this.vestingIncrement=o}},Ee=class{constructor(e,t){this.set=e,this.value=t}setValue(e){this.set=new p(!0),this.value=e}},E=class{constructor(e,t,s){this.constant=e,this.signatureNecessary=t,this.signatureSufficient=s}static impossible(){return new E(new p(!0),new p(!0),new p(!1))}static none(){return new E(new p(!0),new p(!1),new p(!0))}static proof(){return new E(new p(!1),new p(!1),new p(!1))}static signature(){return new E(new p(!1),new p(!0),new p(!0))}static proofOrSignature(){return new E(new p(!1),new p(!1),new p(!0))}static proofAndSignature(){return new E(new p(!1),new p(!0),new p(!1))}},se=class{constructor(e,t,s,n,o,i,a,c,h,l){this.stake=e,this.editState=t,this.send=s,this.receive=n,this.setDelegate=o,this.setPermissions=i,this.setVerificationKey=a,this.setSnappUri=c,this.editRollupState=h,this.setTokenSymbol=l}static default(){return new se(new p(!0),E.proof(),E.signature(),E.proof(),E.signature(),E.signature(),E.signature(),E.signature(),E.proof(),E.signature())}},Ye=class extends C{},Ze=class extends C{},Ce=class{constructor(e,t,s,n,o,i,a){this.appState=e,this.delegate=t,this.verificationKey=s,this.permissions=n,this.snappUri=o,this.tokenSymbol=i,this.timing=a}},Qe=()=>new g(u.one),Me=class{constructor(e,t){this.hash=e,this.events=t}},Ie=class{constructor(){}},V=class{constructor(e,t,s,n,o,i,a,c){this.publicKey=e,this.update=t,this.tokenId=s,this.delta=n,this.events=o,this.sequenceEvents=i,this.callData=a,this.depth=c}static keepAll(e){function t(o){return new Ee(new p(!1),o)}let s=[];for(let o=0;o<Ue;++o)s.push(t(u.zero));let n=new Ce(s,t(new H(A.generator)),t({hash:u.zero,value:void 0}),t(se.default()),t(void 0),t(void 0),t(void 0));return new V(e,n,Qe(),M.zero,new Me(u.zero,[]),u.zero,new Ie,u.zero)}},Pe=class{constructor(e,t){this.check=e,this.value=t}},D=class{static init(e){class t extends D{constructor(){super();this.value=e}get(){throw"init:unimplemented"}set(n){throw"init:unimplmented"}assertEquals(n){throw"init:unimplemented"}}return new t}constructor(){}},we=class{constructor(e,t){this.lower_=e,this.upper_=t}assertBetween(e,t){this.lower=e,this.upper=t}set lower(e){this.lower_=e}get lower(){if(this.lower_===void 0)throw new Error("Cannot get lower before it was set.");return this.lower_}set upper(e){this.upper_=e}get upper(){if(this.upper_===void 0)throw new Error("Cannot get upper before it was set.");return this.upper_}},_e=class{constructor(e,t){this.hash_=e,this.totalCurrency=t}},Te=class{constructor(e,t,s,n,o){this.ledger=e,this.seed_=t,this.startCheckpoint_=s,this.lockCheckpoint_=n,this.epochLength=o}get seed(){if(this.seed_.value===null)throw new Error("Cannot get seed before it was set.");return this.seed_.value}get startCheckpoint(){if(this.startCheckpoint_.value===null)throw new Error("Cannot get startCheckpoint before it was set.");return this.startCheckpoint_.value}get lockCheckpoint(){if(this.lockCheckpoint_.value===null)throw new Error("Cannot get lockCheckpoint before it was set.");return this.lockCheckpoint_.value}},G=class{constructor(e,t,s,n,o,i,a,c,h,l,y){this.snarkedLedgerHash_=e,this.snarkedNextAvailableToken=t,this.timestamp=s,this.blockchainLength=n,this.minWindowDensity=o,this.lastVrfOutput_=i,this.totalCurrency=a,this.globalSlotSinceHardFork=c,this.globalSlotSinceGenesis=h,this.stakingEpochData=l,this.nextEpochData=y}static ignoreAll(){let e=new _e(q(u.zero),oe()),t=new Te(e,q(u.zero),q(u.zero),q(u.zero),X());return new G(q(u.zero),oe(),oe(),X(),X(),q(u.zero),oe(),X(),X(),t,t)}get snarkedLedgerHash(){if(this.snarkedLedgerHash_.check=new p(!0),this.snarkedLedgerHash_.value===null)throw new Error("Cannot get snarkedLedgerHash before it was set.");return this.snarkedLedgerHash_.value}get lastVrfOutput(){if(this.lastVrfOutput_.check=new p(!0),this.lastVrfOutput_.value===null)throw new Error("Cannot get lastVrfOutput before it was set.");return this.lastVrfOutput_.value}};function q(r){return new Pe(new p(!1),r)}var X=()=>new we(f.fromNumber(0),f.MAXINT()),oe=()=>new we(g.fromNumber(0),g.MAXINT()),U=class{constructor(e,t,s,n,o,i,a,c){this.balance=e,this.nonce=t,this.receiptChainHash=s,this.publicKey=n,this.delegate=o,this.state=i,this.sequenceState=a,this.provedState=c}static ignoreAll(){let e=[];for(let t=0;t<Ue;++t)e.push(q(u.zero));return new U(oe(),X(),q(u.zero),q(new H(A.generator)),q(new H(A.generator)),e,q(u.zero),q(new p(!1)))}},Be=class{constructor(e){this.body=e}addInPlace(e){this.body.delta=this.body.delta.add(e)}subInPlace(e){this.body.delta=this.body.delta.sub(e)}},J=class{constructor(e,t){this.body=e,this.predicate=t}get balance(){return new Be(this.body)}get update(){return this.body.update}get publicKey(){return this.body.publicKey}static createUnsigned(e){let t=e,s=V.keepAll(t);if(b===void 0)throw new Error("Party.createUnsigned: Cannot run outside of a transaction");let n=new J(s,void 0);return b.nextPartyIndex++,b.parties.push(n),n}static createSigned(e){let t=e.toPublicKey(),s=V.keepAll(t);return W(t).then(n=>{if(b===void 0)throw new Error("Party.createSigned: Cannot run outside of a transaction");if(n==null)throw new Error("Party.createSigned: Account not found");let o=new J(s,n.nonce);return b.nextPartyIndex++,b.parties.push(o),o})}};var ie={value:0},b,qt=()=>{let r=3*60*1e3,e=new Date().valueOf(),t=ve.create([]),s=()=>f.fromNumber(Math.ceil((new Date().valueOf()-e)/r)),n=(l,y)=>{t.addAccount(l,y)},o=[];for(let l=0;l<10;++l){let y=3e10,x=L.random(),m=x.toPublicKey();n(m,y),o.push({privateKey:x,publicKey:m})}let i=l=>{let y=t.getAccount(l);if(y==null)throw new Error(`getAccount: Could not find account for ${JSON.stringify(l.toJSON())}`);{let x={balance:new g(y.balance.value),nonce:new f(y.nonce.value),snapp:y.snapp};return new Promise(m=>m(x))}};function a(l){return{ledger:{hash:l.ledger.hash_,totalCurrency:l.ledger.totalCurrency},seed:l.seed_,startCheckpoint:l.startCheckpoint_,lockCheckpoint:l.lockCheckpoint_,epochLength:l.epochLength}}let c=l=>({publicKey:l.publicKey,update:l.update,tokenId:l.tokenId,delta:l.delta,events:[],sequenceEvents:[],callData:u.zero,depth:0});return{currentSlot:s,getAccount:i,transaction:(l,y)=>{if(b!==void 0)throw new Error("Cannot start new transaction within another transaction");b={sender:l,parties:[],nextPartyIndex:0,protocolState:G.ignoreAll()};let x=d.runAndCheck(()=>{let F=y();return F instanceof Promise?F.then(()=>()=>{}):new Promise($=>$(()=>{}))}).catch(F=>{throw b=void 0,F}),m=l.toPublicKey(),k=x.then(()=>i(m)).then(F=>{if(b===void 0)throw new Error("Transaction is undefined");let T=b.parties.map(S=>{let B;return S.predicate instanceof f?B={type:"nonce",value:S.predicate}:S.predicate===void 0?B={type:"accept"}:B={type:"full",value:S.predicate},{body:c(S.body),predicate:B}}),$={body:c(V.keepAll(m)),predicate:F.nonce},v=b.protocolState,P={protocolState:{snarkedLedgerHash:v.snarkedLedgerHash_,snarkedNextAvailableToken:v.snarkedNextAvailableToken,timestamp:v.timestamp,blockchainLength:v.blockchainLength,minWindowDensity:v.minWindowDensity,lastVrfOutput:v.lastVrfOutput_,totalCurrency:v.totalCurrency,globalSlotSinceGenesis:v.globalSlotSinceGenesis,globalSlotSinceHardFork:v.globalSlotSinceHardFork,nextEpochData:a(v.nextEpochData),stakingEpochData:a(v.stakingEpochData)},otherParties:T,feePayer:$};return ie.value+=1,b=void 0,P});return{send:()=>{let F=k.then(T=>t.applyPartiesTransaction(T));return{wait:()=>F}}}},addAccount:n,testAccounts:o}},ae={currentSlot:()=>{throw new Error("must call Mina.setActiveInstance first")},getAccount:()=>{throw new Error("must call Mina.setActiveInstance first")},transaction:()=>{throw new Error("must call Mina.setActiveInstance first")}};function At(r){ae=r}function Nt(r,e){return ae.transaction(r,e)}function zt(){return ae.currentSlot()}function W(r){return ae.getAccount(r)}function Vt(r){return ae.getAccount(r).then(e=>e.balance)}var Ae={};ue(Ae,{IPFS:()=>Ot,InMemory:()=>Ht,Keyed:()=>et,OnDisk:()=>Lt});var et=class{static InMemory(e,t,s,n){let o=new Map,i=Q(n),a=R[n],c=new te(n,v=>w.hash(e.toFields(v)),[]),h=0,l=new Map,y=(()=>{let v=e.sizeInFields(),P=[];for(var S=0;S<v;++S)P.push(u.zero);return e.ofFields(P)})(),x=v=>{let P=w.hash(t.toFields(v)),S=l.get(P.toString()),B={value:y,empty:!0};if(S===void 0)return B;{let Y=c.get(S).value;return Y===null?B:{value:Y,empty:!1}}},m=v=>{console.log("getproof");let P=c.getMerklePath(v.value.map(S=>S.toBoolean()));return console.log("getproof"),new i(P)},k=()=>c.root(),F=v=>{let P=w.hash(t.toFields(v)).toString(),S=l.get(P);return S===void 0?null:new a(S.map(B=>new p(B)))},T=()=>{let v=h;return h+=1,a.fromInt(v)};return{depth:n,nextIndex:T,getIndex:F,getProof:m,getValue:x,setValue:(v,P)=>{console.log("setvalu");let S=w.hash(t.toFields(v)).toString(),B=l.get(S),Y=B===void 0?T().value.map(nt=>nt.toBoolean()):B;l.set(S,Y),console.log("setvalu"),c.setValue(Y,P,w.hash(e.toFields(P)))},commitment:k}}};function Ot(r,e){throw"ipfs"}function Ht(r,e){let t=Q(e),s=R[e],n=new te(e,m=>w.hash(r.toFields(m)),[]),o=0,i=new Map;return{getValue:m=>n.get(m.value.map(k=>k.toBoolean())).value,getIndex:m=>{let k=w.hash(r.toFields(m)),F=i.get(k.toString());return F===void 0?null:new s(F.map(T=>new p(T)))},getProof:m=>{console.log("mgetproof");let k=n.getMerklePath(m.value.map(F=>F.toBoolean()));return console.log("mgetproof"),new t(k)},nextIndex:()=>{let m=o;return o+=1,s.fromInt(m)},set:(m,k)=>{d.asProver(()=>{console.log("mset");let F=m.value.map($=>$.toBoolean()),T=w.hash(r.toFields(k));console.log("mset"),i.set(T.toString(),F),n.setValue(F,k,T)})},commitment:()=>n.root(),depth:e}}function Lt(r,e){throw"ondisk"}function Kt(r){return function(e,t,s){let n=e.constructor;if(!(n.prototype instanceof Ne))throw new Error("Can only use @state decorator on classes that extend SmartContract");if(Reflect.getMetadata("design:type",e,t)!=D)throw new Error("@state fields must have type State<A> for some type A");if(t==="_states"||t==="_layout")throw new Error("Property names _states and _layout reserved.");if(n._states===void 0||n._states===null){n._states=[];let c;n._layout=()=>{if(c===void 0){c=new Map;let h=0;n._states.forEach(([l,y])=>{let x=y.sizeInFields();c.set(l,{offset:h,length:x}),h+=x})}return c}}class i extends D{static getLayout(){let l=n._layout().get(t);if(l===void 0)throw new Error(`state ${t} not found`);return l}set(h){let l=i.getLayout(),y=r.toFields(h),x=i._this.executionState();y.forEach((m,k)=>{x.party.body.update.appState[l.offset+k].setValue(m)})}assertEquals(h){let l=i.getLayout(),y=r.toFields(h),x=i._this.executionState();y.forEach((m,k)=>{x.party.predicate.state[l.offset+k].check=new p(!0),x.party.predicate.state[l.offset+k].value=m})}get(){let h=i.getLayout(),l=i._this.address,y;if(d.inProver())y=W(l).then(x=>{let m=[];for(let k=0;k<h.length;++k)m.push(x.snapp.appState[h.offset+k]);return d.witness(d.array(u,h.length),()=>m)});else{let x=d.witness(d.array(u,h.length),()=>{throw"unimplemented"});y=new Promise(m=>m(x))}return y.then(x=>{let m=r.ofFields(x);return r.check!=null&&r.check(m),m})}}n._states.push([t,r]);let a=new i;Object.defineProperty(e,t,{get:function(){return i._this=this,a},set:function(c){i._this=this,a.set(c.value)}})}}function Dt(r,e,t){}function Jt(r,e,t){}var Ne=class{constructor(e){this.address=e;try{this.executionState().party.body.update.verificationKey.set=new p(!0)}catch{throw new Error("Cannot construct `new` SmartContract instance outside a transaction. Use `SmartContract.fromAddress` to refer to an already deployed instance.")}}executionState(){if(b===void 0)throw new Error("Cannot execute outside of a Mina.transaction() block.");if(this._executionState!==void 0&&this._executionState.transactionId===ie.value)return this._executionState;{let e=ie.value,t=b.nextPartyIndex++,s=V.keepAll(this.address),n=U.ignoreAll(),o=new J(s,n);b.parties.push(o);let i={transactionId:e,partyIndex:t,party:o,protocolStatePredicate:b.protocolState};return this._executionState=i,i}}get protocolState(){return this.executionState().protocolStatePredicate}get self(){return this.executionState().party}get balance(){return this.self.balance}get nonce(){let e;if(d.inProver())e=W(this.address).then(t=>d.witness(f,()=>t.nonce));else{let t=d.witness(f,()=>{throw"unimplemented"});e=new Promise(s=>s(t))}return e.then(t=>(this.executionState().party.predicate.nonce.assertBetween(t,t),t))}static fromAddress(e){throw"fromaddress"}party(e){throw"party"}transactionHash(){throw"txn hash"}emitEvent(e){w.hash(e.toFields())}};function $t(r){}function jt(r,e,t){}var tt=class{constructor(e){this.publicInput=e,this.proof=null}assertVerifies(){}};0&&(module.exports={AccountPredicate,AccumulatorMembershipProof,Amount,Balance,Body,Bool,Circuit,CircuitValue,ClosedInterval,Collection,DataStore,EpochDataPredicate,EpochLedgerPredicate,Events,Fee,Field,GlobalSlot,Group,Index,IndexBase,IndexFactory,IndexedAccumulator,Int64,KeyedAccumulatorFactory,Ledger,MerkleAccumulatorFactory,MerkleList,MerkleProof,MerkleProofFactory,MerkleStack,Mina,Optional,OrIgnore,Party,PartyBalance,Perm,Permissions,Poseidon,PrivateKey,ProofWithInput,ProtocolStatePredicate,PublicKey,Scalar,SetOrKeep,Signature,SignedAmount,SmartContract,State,String_,Timing,TokenSymbol,Tree,UInt32,UInt64,Update,arrayProp,asFieldElementsToConstant,branch,circuitMain,getDefaultTokenId,init,isReady,matrixProp,method,proofSystem,prop,public_,shutdown,state});
